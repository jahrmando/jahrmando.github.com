<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Mejorando el rendimiento de PostgreSQL (Linux)</title>
  <meta name="description" content="En estos días me he dado a la tarea de explorar las opciones de optimización que tiene PostgreSQL, ya he tenido la oportunidad de analizar una optimización e...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="jahrmando.github.com/2014/07/15/mejorar-rendimiento-postgresql.html">
  <link rel="alternate" type="application/rss+xml" title="Tech Monkey" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Tech Monkey</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Mejorando el rendimiento de PostgreSQL (Linux)</h1>
    <p class="post-meta">
      <time datetime="2014-07-15T17:36:34-05:00" itemprop="datePublished">
        
        Jul 15, 2014
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>En estos días me he dado a la tarea de explorar las opciones de optimización que tiene PostgreSQL, ya he tenido la oportunidad de analizar una optimización en la configuración general de PostgreSQL (postgresql.conf) de acuerdo con el <em>hardware</em> que tenga el servidor, desde lo cual he visto una mejora en el arranque del servicio y en los tiempos de respuesta de las consultas <strong>sql </strong>a partir de las modificaciones realizadas. Siempre me ayudo con la herramienta <a href="https://github.com/gregs1104/pgtune" target="_blank">pgtune</a> para optimizar estos parámetros importantes, como por ejemplo el <strong><em>shared_buffers</em></strong>, <strong><em>effective_cache_size, etc.</em></strong> para calcular los parámetros óptimos.</p>
<p>Existen dos vertientes por las cuales podemos explorar alguna optimización en nuestro sistema gestor de bases de datos (<strong>SGBD</strong>):</p>
<ol><li><strong>A nivel de consulta</strong>. Que tiene mucho que ver en el empleo de técnicas al realizar las consultas, tales como el manejo de <em>indices</em>, correcto uso de <em>JOINs</em>, etc.</li>
<li>y <strong>a nivel de hardware o sistema operativo</strong>, que es en cuanto a proveer una optimización a nivel de hardware ó configuraciones en el sistema operativo que beneficien al SGBD.</li>
</ol><p>Actualmente estamos en una etapa de auge de las <em>SGBD</em> de tipo NoSQL, sumamente rápidos, muchos de los cuales vemos que sus datos están en tiempo de ejecución en espacio de <em>RAM</em> en el sistema operativo (SO).</p>
<p>Todo acceso de datos en <em>RAM</em> sabemos por demás que es rápida, pero tienen la gran desventaja de que es un espacio volátil y en un <strong>SGDB</strong> es muy importante que los datos se conserven y puedan recuperarse a eventos como apagados repentinos del SO.<!-- more --></p>
<p>Partiendo de la idea de que en <em>RAM</em> los accesos a datos son sumamente rápidos, en la investigación (o <strike>googleada</strike>) encontré un articulo interesante titulado <a href="http://www.appneta.com/blog/postgresql-ram-drive/" target="_blank">&ldquo;Adventures with a PostGreSQL RAM Drive&rdquo;</a>, que en conclusión el autor <strong>Alan Leung</strong> juega con el <strong>Write-Ahead Log</strong> ó <a href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank">WAL</a> sacando le ventaja poniéndolo en <em>RAM</em>, ¿y esto porque?</p>
<p><strong>WAL</strong> le permite a PostgreSQL mantener la <a href="http://es.wikipedia.org/wiki/Atomicidad" target="_blank">atomicidad</a> en los datos, este registra cada evento que es aplicado a los datos, esto nos puede permitir recuperar la base de datos en caso de un apagón de servidor. <strong>WAL</strong> viene activado por defecto y no es conveniente desactivarlo.</p>
<p>Ya que cada transacción es registrada en <strong>WAL</strong> esto genera un tiempo extra de espera en cada transacción, entonces tener un mejor tiempo de I/O depende mucho de la<strong><em> configuración y tipo</em></strong> de disco duro donde este alojado <strong>WAL</strong> (el directorio es <strong><em>pg_xlog</em></strong>) y también los archivos de las bases de datos (el directorio es <strong>pg_data</strong>)</p>
<p>En el <a href="http://www.postgresql.org/docs/9.1/static/wal-internals.html" target="_blank">sitio oficial</a> de postgresql en el segmento de <strong>WAL</strong> nos comenta:</p>
<blockquote>
<p>It is advantageous if the log is located on a different disk from the main database files.</p>
</blockquote>
<p>Esto suena lógico, si mantenemos por separado la carga de I/O de <strong>WAL</strong> y de los datos debemos tener un mejor tiempo en cada transacción. Esto lo prueba <strong>Alan Leung</strong> y nos muestra una mejora del 5% de TPS (<a href="http://en.wikipedia.org/wiki/Transactions_per_second" target="_blank">Transactions per second</a>).</p>
<p>Ahora realizamos la misma acción, pero en este caso movemos los registros <em>WAL</em> a espacio de <em>RAM</em> en teoría debería de mejorar resultados en <em>TPS</em>, y esto igual lo prueba Alan Leung, teniendo un incremento del 70% del rendimiento en <em>TPS</em> como resultado. Increíblemente ahora tenemos un mejor y destacable incremento de performance.</p>
<h2 id="probando-la-teoria">Probando la teoría</h2>
<p>Yo he realizado igual las mismas pruebas que <em>Alan Leung</em>, he montado un CentOS virtualizado en un <strong><em>virtualbox</em></strong> con lo siguiente:</p>
<ul><li>CentOS 6.5 x86_64</li>
<li>1GB de RAM</li>
<li>8G de Disco virtual</li>
<li>PostgreSQL 9.2</li>
</ul><p>Usare <code>pgbench</code> para realizar pruebas de rendimiento a PostgreSQL, he realizado la primera prueba manteniendo <em>WAL</em> en disco duro obteniendo el siguiente resultado:</p>
<pre><code>$ pgbench -h localhost -p 5432 -U dbadmin -c 10 -t 10000 testdb
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 10000
number of transactions actually processed: 100000/100000
tps = 590.213182 (including connections establishing)
tps = 590.281717 (excluding connections establishing)
</code></pre>
<p>Vemos que tenemos aproximadamente unos <strong><em>590tps</em></strong>. Ahora ejecutare la misma prueba pero ahora con <em>WAL</em> en espacio de <em>RAM</em>:</p>
<pre><code>$ pgbench -h localhost -p 5432 -U dbadmin -c 10 -t 10000 testdb
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 10000
number of transactions actually processed: 100000/100000
tps = 1982.478380 (including connections establishing)
tps = 1983.162671 (excluding connections establishing)
</code></pre>
<p>Nos da como resultado unos <strong><em>1983tps</em></strong>, el performance a incrementado 3 veces, sumamente valioso.</p>
<p>Obviamente queda demostrado que mover a espacio de <em>RAM</em> a WAL nos incrementa el performance, hasta este punto no estamos moviendo nuestros datos a <em>RAM</em>, lo cual queda en espacio de disco y esta a salvo, pero tener a WAL en <em>RAM</em> arriesgamos nuestro proceso de atomicidad y es muy importante tenerlo integro en caso de desastres.</p>
<p>Esto me deja pensando, ¿es realmente factible tener nuestro WAL en <em>RAM</em>? (hablando en disponibilidad de recursos). WAL pesa entre unos 16MB mínimo a 1G aproximadamente y esto depende mucho de las bases de datos alojados en el servicio PostgreSQL, también sabemos que si tenemos contratado algún servicio <strong>VPS</strong> el costo mas alto siempre es el de <em>RAM</em>, entonces implementar este performance queda a <strong><em>la disponibilidad de los recursos de RAM y hasta de tipo monetarios</em></strong>.</p>
<p>Supongamos que tenemos “toda” la <em>RAM</em> necesaria y que eso no es problema, continuemos con las pruebas.</p>
<p>Ahora necesitamos un proceso <strong><em>FAILOVER</em></strong> (tolerancia a fallos), que nos permita recuperar y resguardar nuestro WAL a un disco duro en caso de algún apagón y este evento no nos haga perder los datos que están en <em>RAM</em>.</p>
<p>La propuesta es:</p>
<ul><li>Configurar dos servicios PostgreSQL y replicar en modo maestro-esclavo.</li>
<li>Usando los <strong><em>script</em></strong> de inicio de PostgreSQL haremos la verificación de la partición en espacio de <em>RAM</em>.</li>
</ul><h2 id="replicacion-de-postgresql">Replicación de PostgreSQL</h2>
<p>Tener una instancia esclava del servidor maestro nos permite tener una <strong><em>copia de WAL</em></strong> en otra instancia que este en un espacio de disco duro, esto para poder recuperar una copia en caso de un apagado repentino del servidor.</p>
<p>Vamos a configurar una replicación de tipo <a href="http://www.postgresql.org/docs/9.2/static/warm-standby.html" target="_blank">&ldquo;Log-Shipping Standby Servers&rdquo;</a>.</p>
<blockquote>
<p>En este caso lo haremos las configuraciones en el mismo servidor y los servicios usaran el mismo disco duro. Podemos tener el esclavo en otro servidor físico o tenerlo en otro disco en el mismo servidor fisico.</p>
</blockquote>
<h3 id="configuracion-del-servicio-maestro">Configuración del servicio maestro.</h3>
<p>Editamos el archivo principal de configuración los parámetros para <em>WAL</em>.</p>
<pre><code>$ vim /var/lib/pgsql/9.2/data/postgresql.conf
wal_level = hot_standby
max_wal_senders = 1
wal_keep_segments = 50
archive_command = 'cp %p /tmp/backup/db001/%f'
archive_mode = on
</code></pre>
<p>Editamos el archivo de configuración de accesos.</p>
<pre><code>$ vim /var/lib/pgsql/9.2/data/pg_hba.conf
host    replication     postgres        127.0.0.1/32            trust
host    replication     postgres        ::1/128                 trust
</code></pre>
<p>Reiniciamos el servidor maestro.</p>
<pre><code>service postgresql-9.2 restart
</code></pre>
<p>Ahora crearemos un <strong>snapshot</strong> de nuestro servicio maestro para el servicio esclavo.</p>
<pre><code>$ su - postgres
-bash-4.1$ psql -c "SELECT pg_start_backup('mi_backup');"
-bash-4.1$ cp -rvf /var/lib/pgsql/9.2/data /tmp/
-bash-4.1$ psql -c "SELECT pg_stop_backup();"
-bash-4.1$ exit
</code></pre>
<h3 id="configuraciones-del-servicio-esclavo">Configuraciones del servicio esclavo</h3>
<p>Hacemos una copia del <em>script</em> de inicio del servicio PostgreSQL del sistema y los llamaremos <strong><em>postgresql-slave9.2</em></strong></p>
<pre><code>$ cp /etc/init.d/postgresql-9.2 /etc/init.d/postgresql-slave9.2
</code></pre>
<p>Modificamos los siguientes parámetros en el script. Usaremos el puerto <em><strong>5433</strong></em> y el directorio <strong><em>/var/lib/pgsql/9.2/data_slave</em></strong> para el servicio esclavo.</p>
<pre><code>$ vim /etc/init.d/postgresql-slave9.2
PGPORT=5433
PGDATA=/var/lib/pgsql/9.2/data_slave
PGLOG=/var/lib/pgsql/9.2/pgstartup_slave.log
</code></pre>
<p>Agregamos el <em>script</em> al sistema de inicio y lo activamos.</p>
<pre><code>$ chkconfig --add postgresql-slave9.2
$ chkconfig postgresql-slave9.2 on
</code></pre>
<p>Copiamos el <strong><em>snapshot</em></strong> maestro al que sera el directorio del servicio esclavo.</p>
<pre><code>$ su - postgres
-bash-4.1$ mv /tmp/data /tmp/data_slave
-bash-4.1$ cp -rvf /tmp/data_slave /var/lib/pgsql/9.2/
</code></pre>
<p>Editamos estos parámetros mínimos para nuestra nueva instancia.</p>
<pre><code>$ vim /var/lib/pgsql/9.2/data_slave/postgresql.conf
listen_addresses = '*'
port = 5433
wal_level = hot_standby
archive_mode = on
archive_command = '/bin/true'
hot_standby = on
</code></pre>
<p>Podemos usar la misma política de acceso que tenemos en nuestra instancia maestra a la nueva instancia esclava si así lo consideramos optimo, solo que tendremos que comentar las lineas de <strong>replication</strong>.</p>
<pre><code>$ vim /var/lib/pgsql/9.2/data/pg_hba.conf
#host    replication     postgres        127.0.0.1/32            trust
#host    replication     postgres        ::1/128                 trust
</code></pre>
<p>Eliminar el <strong><em>postmaster.pid</em></strong> y los archivos <strong><em>pg_xlog</em></strong>.</p>
<pre><code>$ rm -f /var/lib/pgsql/9.2/data_slave/postmaster.pid
$ rm -r /var/lib/pgsql/9.2/data_slave/pg_xlog/*
</code></pre>
<p>Creamos el archivo <strong><em>recovery.conf</em></strong> que es indispensable para que nuestro servicio esclavo empiece a replicar.</p>
<pre><code>$ cp /usr/pgsql-9.2/share/recovery.conf.sample /var/lib/pgsql/9.2/data_slave/recovery.conf
$ chown postgres.postgres /var/lib/pgsql/9.2/data_slave/recovery.conf
</code></pre>
<p>Agregamos las siguiente configuracion a<strong> <em>recovery.conf</em></strong></p>
<pre><code>$ vim /var/lib/pgsql/9.2/data_slave/recovery.conf
standby_mode = 'on'
primary_conninfo = 'host=127.0.0.1 port=5432 user=postgres'
trigger_file = '/tmp/postgresql.slave.trigger'
restore_command = 'cp /tmp/backup/db001/%f \"%p\"'
</code></pre>
<p>Iniciamos el servicio esclavo.</p>
<pre><code>$ service postgresql-slave9.2 start
</code></pre>
<p>Hasta este punto debemos tener dos servicios completamente replicados, probemos creando una tabla en el maestro y revisemos si en nuestro esclavo esta replicado (recordemos que el esclavo esta en modo <strong><em>read-only</em></strong>).</p>
<p>Importante revisar en los registros(<strong><em>/var/lib/pgsql/9.2/data_slave/pg_log/</em></strong>) de inicio del esclavo el siguiente mensaje:</p>
<pre><code>2014-07-00 00:00:00.177 UTC [-1993-] LOG:  streaming replication successfully connected to primary
</code></pre>
<h3 id="configuracion-de-wal-en-ram">Configuracion de WAL en RAM.</h3>
<p>Esta idea es de contener en <em>RAM</em> los archivos WAL (<strong>pg_xlog</strong>) y para llegar a ello haremos lo siguiente:</p>
<ul><li>El servidor maestro tendra el directorio <strong>pg_xlog</strong> en la partición <em>RAM</em>, lo cual crearemos un enlace simbolico del directorio <strong>pg_xlog</strong> que apunte a la partición <em>RAM</em>.</li>
<li>El servidor esclavo tendra el directorio <strong>pg_xlog</strong> en Disco duro.</li>
</ul><p>Si tenemos un servicio de replicacion en buen estado cuando apaguemos los servicios PostgreSQL debemos tener una copia exacta del <em>WAL</em> que contenemos en <em>RAM</em> con el que esta en disco duro.</p>
<p>En consecuencia haremos lo siguiente:</p>
<ul><li>Adecuar el arranque del maestro para que este recupere su WAL a partir del <em>WAL</em> del esclavo antes de iniciar.</li>
</ul><p>El esclavo al iniciar realiza una comprobación para saber si contienen el mismo <em>WAL</em> para poder arrancar, lo cual será el mismo ya que es una copia.</p>
<p>Creamos el directorio donde alojaremos la particion RAM.</p>
<pre><code>$ mkdir /mnt/ramdisk
$ chown postgres.postgres /mnt/ramdisk
</code></pre>
<p>Configuramos el <strong>fstab</strong> para montar la particion al inicio del sistema. Esta partición tendrá una capacidad de 1G.</p>
<pre><code>$ vim /etc/fstab
tmpfs   /mnt/ramdisk    tmpfs   size=1024M  0 0
</code></pre>
<p>Probemos la configuracion <strong><em>fstab</em></strong> montando todas las particiones declaradas en la configuracion con <code>mount</code> y verificamos con <code>df</code>.</p>
<pre><code>$ mount -a
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       7.9G  4.8G  2.7G  64% /
tmpfs           939M     0  939M   0% /dev/shm
tmpfs             1G    4M  1020M   1% /mnt/ramdisk
</code></pre>
<p>Detenemos los servicios PostgreSQL.</p>
<pre><code>$ service postgresql-9.2 stop &amp;&amp; service postgresql-slave9.2 stop
</code></pre>
<p>Ahora vamos a mover el directorio <strong><em>pg_xlog</em></strong> del servicio maestro a la particion <em>RAM</em>.</p>
<pre><code>$ cd /var/lib/pgsql/9.2/data/
data$ mv pg_xlog /mnt/ramdisk/
data$ chown postgres.postgres -R /mnt/ramdisk/pg_xlog
</code></pre>
<p>Creamos un enlace directo llamado <strong><em>pg_xlog</em></strong> que apunte a nuestra particion RAM y verificamos los directorios.</p>
<pre><code>data$ ln -s /mnt/ramdisk/pg_xlog
data$ ls -l
total 136
drwx------ 10 postgres postgres  4096 Jun 25 19:34 base
drwx------  2 postgres postgres  4096 Jul  9 17:39 global
drwx------  2 postgres postgres  4096 May 30 20:36 pg_clog
-rw-------  1 postgres postgres  4349 Jun 24 16:51 pg_hba.conf
-rw-------  1 postgres postgres  1636 May 30 20:36 pg_ident.conf
drwx------  2 postgres postgres  4096 Jun 23 16:40 pg_log
drwx------  4 postgres postgres  4096 May 30 20:36 pg_multixact
drwx------  2 postgres postgres  4096 Jul 14 22:43 pg_notify
drwx------  2 postgres postgres  4096 May 30 20:36 pg_serial
drwx------  2 postgres postgres  4096 May 30 20:36 pg_snapshots
drwx------  2 postgres postgres  4096 Jul 14 23:21 pg_stat_tmp
drwx------  2 postgres postgres  4096 Jun 25 19:08 pg_subtrans
drwx------  2 postgres postgres  4096 Jun 27 23:06 pg_tblspc
drwx------  2 postgres postgres  4096 May 30 20:36 pg_twophase
-rw-------  1 postgres postgres     4 May 30 20:36 PG_VERSION
lrwxrwxrwx  1 root     root        21 Jun 24 19:50 pg_xlog -&gt; /mnt/ramdisk/pg_xlog
-rw-------  1 postgres postgres 20332 Jun 24 19:04 postgresql.conf
-rw-------  1 postgres postgres    71 Jul 14 22:43 postmaster.opts
-rw-------  1 postgres postgres    72 Jul 14 22:43 postmaster.pid
</code></pre>
<p>Hasta este punto podemos iniciar los servicios PostgreSQL y verificar la replicacion ingresando datos a una tabla de prueba.</p>
<pre><code>$ service postgresql-9.2 start &amp;&amp; service postgresql-slave9.2 start
</code></pre>
<p>Todo debe funcionar correctamente y tener una replicacion exitosa.</p>
<p>Ahora debemos modificar el script <em>bash</em> de inicio del servicio maestro para que antes de iniciar verifique si existe el directorio <em>/mnt/ramdisk/pg_xlog</em> y si no existe obtener la copia del servidor esclavo.</p>
<pre><code>$ vim /etc/init.d/postgresql-9.2
# Replication configs. Lo agregamos aproximadamente en la linea 88.
PG_XLOG_MASTER=/mnt/ramdisk/pg_xlog
PG_XLOG_SLAVE=/var/lib/pgsql/9.2/data_slave/pg_xlog
#
# Esta condicion la colocamos dentro de la funcion START. Aproximadamente en la linea 118.
if [ ! -d "$PG_XLOG_MASTER" ]; then
        cp -r "$PG_XLOG_SLAVE" "/mnt/ramdisk/"
        chown postgres:postgres -R "$PG_XLOG_MASTER"
fi
</code></pre>
<p>Con esta modificacion podemos garantizar de que nuestro <strong><em>pg_xlog</em></strong> este en <em>RAM</em> para que pueda iniciar el servicio maestro.</p>
<p>Hagamos una prueba, detengamos los servicios PostgreSQL, borremos el directorio <strong><em>/mnt/ramdisk/pg_xlog</em></strong> e iniciemos los servicios PostgreSQL nuevamente.</p>
<pre><code>$ service postgresql-9.2 stop &amp;&amp; service postgresql-slave9.2 stop
$ rm -rf /mnt/ramdisk/pg_xlog
$ service postgresql-9.2 start &amp;&amp; service postgresql-slave9.2 start
</code></pre>
<p>Hasta este punto debe estar todo funcionando y si no es asi verifique sus configuraciones.</p>
<p>Lo que sigue es comprobar que el sistema operativo pueda apagarse e iniciarse con los servicios postgresql, si no tuvimos problemas con ejecutar los comandos anteriores el <strong>reiniciar</strong> el sistema no debe causarnos problema.</p>
<pre><code>$ reboot
</code></pre>
<p>He realizado las siguientes pruebas:</p>
<ul><li>Reinicio normal del sistema.</li>
<li>Apagado directo del sistema.</li>
<li>Matando el proceso maestro.</li>
<li>Matando el proceso esclavo.</li>
</ul><p>En todas no he tenido problemas con la integridad de los datos y del registro WAL.</p>
<blockquote>
<p>Si tienes en mente alguna otra prueba de fallo para probar la robustez de la configuración puedes dejármelo como comentario al final del articulo y con gusto lo ejecutamos.</p>
</blockquote>
<p>Consideraciones para esta configuración:</p>
<ul><li>Siempre estar pendiente que nuestros servicios esten replicando correctamente. Un servicio como <strong><em>Nagios</em></strong> nos puede servir para esto.</li>
<li>Tener un servicio replicado con lleva a tener en cuenta los <strong><em>troubleshootings</em></strong> de este tipo de configuracion.</li>
<li>Si el directorio <em>WAL</em> esta creciendo demaciado podemos “<em>purgar</em>” el directorio. Este <a href="http://ag-up.com/?p=840" target="_blank">articulo</a> nos muestra como.</li>
</ul><p>Ahora bien ejecutemos el <code>pgbench</code> de nueva cuenta con nuestra actual configuracion.</p>
<pre><code>$ pgbench -h localhost -p 5432 -U dbadmin -c 10 -t 10000 testdb
Password: 
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 10000
number of transactions actually processed: 100000/100000
tps = 1479.385379 (including connections establishing)
tps = 1480.620177 (excluding connections establishing)
</code></pre>
<p>Nos arroja un <em><strong>1480tps</strong></em>, es un son como <strong><em>500tps</em></strong> menos en comparacion cuando teniamos el servidor en standalone con <em>WAL</em> en <em>RAM</em> (aunque prácticamente sigue siendo alto), esto lo atribuyo a que ahora en el sistema tiene mas carga de procesos, ya que son dos servicios PostgreSQL y tambien porque hemos dublicado las peticiones I/O del disco y el performance en el disco duro puede castigarse, pero es aceptable el performance de <strong><em>TPS</em></strong> que se obtiene.</p>
<h3 id="tablespace-en-ram">TABLESPACE en RAM</h3>
<p>En PostgreSQL tenemos algo llamado <a href="http://www.postgresql.org/docs/9.2/static/sql-createtablespace.html" target="_blank"><strong><em>tablespace</em></strong></a>, que es practicamente tener la posibilidad de configurar el directorio donde quiero que se guarde una tabla.</p>
<blockquote>
<p>Por defecto tenemos una <strong><em>tablespace</em></strong> llamada pg_default a que punta al directorio pg_data</p>
</blockquote>
<p>PostgreSQL realiza esto de la siguiente forma:</p>
<ul><li>Genera un <strong><em>enlace simbólico</em></strong> nombrado con un <em><strong>ID</strong></em> numerico y este apunta al directorio que has configurado.</li>
</ul><p>Estos enlaces simbólicos son guardados en el directorio <strong>pg_tblspc</strong>.</p>
<p>Partiendo de la idea de que podemos manipular la ruta donde podemos mover nuestras tablas en la base de datos es posible aplicar la misma tecnica usada en <em>WAL</em> y poder tener ciertas tablas en <em>RAM</em>.</p>
<p>Tener tablas en <em>RAM</em> nos proporcionar un alto performance en <em>TPS</em>.</p>
<blockquote>
<p>Existen tablas de tipo <a href="http://www.postgresql.org/docs/9.2/interactive/sql-createtable.html" target="_blank">TEMPORARY</a> en PostgreSQL que son ejecutadas en espacio de <em>RAM </em>pero estas son eliminadas al final de la sesion o transaccion.</p>
</blockquote>
<p>Debemos considerar algunas recomendaciones para tener tablas en <em>RAM</em>, como:</p>
<ul><li>Solo contener tablas que sean de alta lectura y poca escritura.</li>
<li>Monitorear el crecimiento de la(s) tabla(s).</li>
</ul><p>Teniendo esto encuenta pasemos a la configuraciones de nuestro <strong><em>tablespace</em></strong> en <em>RAM</em>.</p>
<p>Nos conectamos al servidor maestro.</p>
<pre><code>$ su - postgres -c 'psql -p5432'
</code></pre>
<p>Estando ya en la sesion del usuario <em>postgres</em> ejecutamos la sentencia para crear el <strong><em>tablespace</em></strong>, este lo apuntaremos hacia nuestra particion <em>RAM</em> ya configurada <em>/mnt/ramdisk</em>.</p>
<pre><code>postgres=# CREATE TABLESPACE ramspace OWNER dbadmin LOCATION '/mnt/ramdisk/ramspace';
</code></pre>
<p>Con la sentencia <code>SELECT * FROM pg_tablespace</code> listamos nuestros <strong><em>tablespace</em></strong> disponibles y vemos que tenemos a <strong>ramspace</strong> ya creado.</p>
<pre><code>postgres=# SELECT * FROM pg_tablespace;
  spcname   | spcowner | spcacl | spcoptions 
------------+----------+--------+------------
 pg_default |       10 |        | 
 pg_global  |       10 |        | 
 ramspace   |    16384 |        |
</code></pre>
<p>Previamente he creado una base de datos llamada <strong>db_test</strong> y dentro de ella vamos a crear una tabla llamada <strong>prueba_ram2</strong>.</p>
<pre><code>postgres=# \connect db_test
db_test=# CREATE TABLE prueba_ram2(valor char(100)) TABLESPACE ramspace;
db_test=# ALTER TABLE prueba_ram2 OWNER TO dbadmin;
</code></pre>
<p>Ahora bien vamos a verificar que nuestro tablespace que esta en el directoio <strong>pg_tblspc</strong> este apuntando al directorio de la particion RAM. Podemos observar que le asigno la ID <strong>55061</strong>.</p>
<pre><code>$ ls -l /var/lib/pgsql/9.2/data/pg_tblspc
total 0
lrwxrwxrwx 1 postgres postgres 14 2014-06-27 23:06 55061 -&gt; /mnt/ramdisk/ramspace
</code></pre>
<p>Y podemos observar tambien que tenemos <strong><em>el mismo enlace directo</em></strong> generado en el servidor <strong>esclavo</strong></p>
<pre><code>$ ls -l /var/lib/pgsql/9.2/data_slave/pg_tblspc
total 0
lrwxrwxrwx 1 postgres postgres 14 2014-06-27 23:06 55061 -&gt; /mnt/ramdisk/ramspace
</code></pre>
<p>Lo siguiente es manipular el enlace directo del <strong><em>servidor esclavo</em></strong> y redireccionarlo a un directorio que este en el disco duro. Pero antes de esto tenemos que detener nuestros servicios PostgreSQL.</p>
<pre><code>$ service postgresql-9.2 stop &amp;&amp; service postgresql-slave9.2 stop
</code></pre>
<p>Creamos una copia de <em>ramspace</em> al directorio <em>/opt/</em> y le asignamos el propieratio <em>postgres</em>.</p>
<pre><code>$ cp -rvf /mnt/ramdisk/ramspace /opt/ramspace
$ chown postgres.postgres /mnt/ramdisk/ram_space
</code></pre>
<p>Ahora vamos a redireccionar el enlace del <strong><em>servicio esclavo</em></strong> a la copia generada anteriormente.</p>
<pre><code>$ cd /var/lib/pgsql/9.2/data_slave/pg_tblspc/
$ rm 55061
$ ln -s /opt/ramspace 55061
</code></pre>
<p>Verificamos que el enlace este creado y apuntando a <em>/opt/ramspace</em>.</p>
<pre><code>$ ls -l /var/lib/pgsql/9.2/data_slave/pg_tblspc
total 0
lrwxrwxrwx 1 postgres postgres 22 2014-06-27 23:27 55061 -&gt; /opt/ramspace
</code></pre>
<p>Y por ultimo iniciamos nuestros servicios PostgreSQL.</p>
<pre><code>$ service postgresql-9.2 start &amp;&amp; service postgresql-slave9.2 start
</code></pre>
<blockquote>
<p>Verifiquemos que nuestra replicacion siga funcionando, podemos insertar datos en la tabla que tenemos en <em>RAM</em> y verificar en el esclavo la replicacion.</p>
</blockquote>
<p>Lo siguiente ahora es agregar una verificación en el <strong><em>script</em></strong> de inicio del servicio maestro como lo hicimos anteriormente, para garantizar que inicie con el <strong><em>tablespace</em></strong>.</p>
<pre><code>$ vim /etc/init.d/postgresql-9.2
# Replication configs. Agregar aprox linea 90
PG_BASE=/mnt/ramdisk/ramspace
PG_BASE_SLAVE=/opt/ramspace
#
# Agregar en aprox. linea 120
if [ ! -d "$PG_BASE" ]; then
        cp -r "$PG_BASE_SLAVE" "/mnt/ramdisk/"
        chown postgres:postgres -R "$PG_BASE"
fi
</code></pre>
<h3 id="conclusiones">Conclusiones</h3>
<p>Podemos usar esta configuracion en produccion siempre y cuando estemos verificando el uso de espacio de <em>RAM.</em> Como dije anteriormente, la <em>RAM</em> es un recurso muchas veces muy limitado y debemos tener en cuenta eso, el uso de espacio que pueda usar <em>WAL</em> depende mucho de la cantidad de datos y el nivel de transacciones que se registren en la base de datos que hacen crecer a <em>WAL</em>, sin embargo si nuestra base es de altas transacciones por día convendría solo usar el<em> hack del tablespace</em> en tablas donde se presente muchas consultas de lectura y obtendriamos una mejor en perfomance en <em>TPS</em> sobre esa(s) tabla(s).</p>
<p>Como siempre conviene hacer un análisis a largo plazo del crecimiento de la base de datos y corroborar que nuestro hardware en <em>RAM</em> pueda soportarlo. El beneficio es bastante bueno en <em>TPS</em>.</p>
<p>Espero este articulo les haya servido, si tienen ideas que puedan mejorar la configuracion me encantaria poder saberlo y actualizar el articulo con sus hacks.</p>
<p><em>Algunas fuentes:</em></p>
<ul><li><em><a href="http://magazine.redhat.com/2007/12/12/tip-from-an-rhce-memory-storage-on-postgresql/" target="_blank">Tips and tricks: Memory storage on PostgreSQL</a></em></li>
<li><em><a href="http://opensourcedbms.com/dbms/running-multiple-postgresql-9-2-instances-on-one-server-in-centos-6rhel-6fedora/" target="_blank">Running multiple PostgreSQL 9.2 Instances on one server in CentOS 6/RHEL 6/Fedora</a></em></li>
<li><em><a href="http://www.appneta.com/blog/postgresql-ram-drive/" target="_blank">Adventures with a PostGreSQL RAM Drive</a></em></li>
<li><em><a href="http://www.postgresql.org/docs/9.1/static/pgbench.html" target="_blank">pgbench</a></em></li>
</ul>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Tech Monkey</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Tech Monkey
            
            </li>
            
            <li><a href="mailto:me@jahrmando.com">me@jahrmando.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jahrmando"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jahrmando</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/jahrmando"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">jahrmando</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>An Accidental Engineer • Tech Monkey • #Linux #DevOps #Programmer #Infosec
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
